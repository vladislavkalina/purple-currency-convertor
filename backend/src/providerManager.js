var providers = [];
var cachedCurrencyCodeList = [];

exports.initialize = (initProviders) => {
    providers = initProviders.map(provider => {
        return {
            api: provider,                      // provider object, must implement convert() and getCurrencyCodeList()
            priority: Number.MAX_SAFE_INTEGER,  // priority calculated from remainig quota
            disabledFor: 1,                     // number of second for next delay after failure
            disabledUntil: 0                    // timestamp of next attempt after failure
        };
    });
}

exports.currencyCodeList = async () => {
    if (cachedCurrencyCodeList.currencyCodes !== undefined) {
        console.log("Using cached code list", cachedCurrencyCodeList.currencyCodes.length);
        return cachedCurrencyCodeList;
    }
    // TODO: we should watch the age of the cached list and refresh it from time to time

    let codelist = await providers[0].api.getCurrencyCodeList();
    if (codelist.error === undefined) {
        cachedCurrencyCodeList = codelist;
        console.log("Caching received code list");
    }
    return codelist;
    // TODO: we should call all provides, compare the results and use intersection(?) because
    // the lists provided by different providers may not be equal. But Fixer counts all requests,
    // including getting code list, and the allowance of free 100 requests is used up too quickly.
}

exports.convertWithBestProvider = async (parameters) => {
    let highestPriorityIndex = findHighestPriorityProviderIndex();
    let result = await providers[highestPriorityIndex].api.convert(parameters);

    /* TODO: We have multiple providers so we can call others in case of failure
    while (result.error !== undefined) {
        providers[highestPriorityIndex].disabledUntil = Date.now() + providers[highestPriorityIndex].disabledFor;
        providers[highestPriorityIndex].disabledFor *= 2;
        highestPriorityIndex = findHighestPriorityProviderIndex();
        result = await providers[highestPriorityIndex].api.convert(parameters);
    }
    */

    if (result.error === undefined) {
        updatePriority(highestPriorityIndex, result);
    }

    providers[highestPriorityIndex].disableFor = 1; // reset the failover delay after a successful usage

    return result;
    // TODO: Forwarding the error generated by the particular provider. In the real world we might
    // want to define own code&message here.
}

function findHighestPriorityProviderIndex() {
    let highestPriorityIndex = 0;
    providers.forEach((provider, index) => {
        console.log("Provider #", index, "has priority", provider.priority);
        if (provider.priority > providers[highestPriorityIndex].priority
            && providers[highestPriorityIndex].disabledUntil < Date.now()) {
            highestPriorityIndex = index;
        }
    });
    console.log("Best provider is #", highestPriorityIndex)
    return highestPriorityIndex;
}

function updatePriority(provideIndex, parameters) {
    // console.log(parameters);
    let quotaPercentRemaining = parameters.remainingQuota.requestsRemaining / parameters.remainingQuota.requestsQuota;
    let quotaPercentRemainingPerDay = quotaPercentRemaining / parameters.remainingQuota.daysRemaining;
    providers[provideIndex].priority = quotaPercentRemainingPerDay;
    console.log(parameters.remainingQuota.requestsRemaining, "remains which is",
        quotaPercentRemaining, "% for ",
        parameters.remainingQuota.daysRemaining, "days which is ",
        quotaPercentRemainingPerDay, " per day");
}