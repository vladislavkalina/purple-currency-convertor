OpenexchangeratesClient = require("./openexchangeratesClient.js");
FixerClient = require("./fixerClient.js");
CurrencylayerClient = require("./currencylayerClient.js");

var providers = [];
var cachedCurrencyCodeList = [];

exports.initialize = (apiKeys) => {
    let initProviders = [];
    if (apiKeys.openexchangeratesAppIds && Array.isArray(apiKeys.openexchangeratesAppIds)) {
        apiKeys.openexchangeratesAppIds.forEach(key => {
            initProviders.push(new OpenexchangeratesClient(key));
        });
    } else {
        console.warn("No api keys provided for OpenExchangerates");
    }
    if (apiKeys.fixerApiKeys && Array.isArray(apiKeys.fixerApiKeys)) {
        apiKeys.fixerApiKeys.forEach(key => {
            initProviders.push(new FixerClient(key));
        });
    } else {
        console.warn("No api keys provided for Fixer");
    }
    if (apiKeys.currencylayerApiKeys && Array.isArray(apiKeys.currencylayerApiKeys)) {
        apiKeys.currencylayerApiKeys.forEach(key => {
            initProviders.push(new CurrencylayerClient(key));
        });
    } else {
        console.warn("No api keys provided for CurrencyLayer");
    }

    providers = initProviders.map(provider => {
        return {
            api: provider,                      // provider object, must implement convert() and getCurrencyCodeList()
            priority: Number.MAX_SAFE_INTEGER,  // priority calculated from remainig quota
            disabledFor: 1000,                  // number of millisecond for next delay after failure
            disabledUntil: 0                    // timestamp of next attempt after failure
        };
    });

    if (providers.length === 0) {
        console.error("No provider was configured, we won't be able to provide any responses to the frontend")
    }
}

exports.currencyCodeList = async () => {
    if (cachedCurrencyCodeList.currencyCodes !== undefined) {
        console.log("Using cached code list", cachedCurrencyCodeList.currencyCodes.length);
        return cachedCurrencyCodeList;
    }
    // TODO: we should watch the age of the cached list and refresh it from time to time

    let codelist = await providers[0].api.getCurrencyCodeList();
    if (codelist.error === undefined) {
        cachedCurrencyCodeList = codelist;
        console.log("Caching received code list");
    }
    return codelist;
    // TODO: we should call all provides, compare the results and use intersection(?) because
    // the lists provided by different providers may not be equal. But Fixer counts all requests,
    // including getting code list, and the allowance of free 100 requests is used up too quickly.
}

exports.convertWithBestProvider = async (parameters) => {
    let highestPriorityIndex = findHighestPriorityProviderIndex();
    let result = await providers[highestPriorityIndex].api.convert(parameters);

    while (result.error !== undefined) { // TODO: We should think of a timeout here in case all providers keep failing
        providers[highestPriorityIndex].disabledUntil = Date.now() + providers[highestPriorityIndex].disabledFor;
        console.warn("Provider at index", highestPriorityIndex, "failed. We will be skipping it for", providers[highestPriorityIndex].disabledFor, "milliseconds which is until", providers[highestPriorityIndex].disabledUntil);
        providers[highestPriorityIndex].disabledFor *= 2;
        highestPriorityIndex = findHighestPriorityProviderIndex();
        result = await providers[highestPriorityIndex].api.convert(parameters);
    }

    if (result.error === undefined) {
        updatePriority(highestPriorityIndex, result);
        providers[highestPriorityIndex].disabledFor = 1; // reset the failover delay after a successful usage
    }

    return result;
    // TODO: Forwarding the error generated by the particular provider. In the real world we might
    // want to define own code&message here.
}

function findHighestPriorityProviderIndex() {
    let highestPriorityIndex = 0;
    providers.forEach((provider, index) => {
        console.log("Provider #", index, "has priority", provider.priority);
        if (provider.priority > providers[highestPriorityIndex].priority) {
            if (providers[index].disabledUntil < Date.now()) {
                // console.log("Provider at index", index, "was disabled until", providers[index].disabledUntil, "but it's now", Date.now());
                highestPriorityIndex = index;
            } else {
                console.log("Provider at index", index, "has higher priority but after previous failure it is disabled until", providers[index].disabledUntil);
                // TODO: We should think about what happens if all providers are disabled
            }
        }
    });
    console.log("Best provider is #", highestPriorityIndex)
    return highestPriorityIndex;
}

function updatePriority(provideIndex, parameters) {
    // console.log(parameters);
    let quotaPercentRemaining = parameters.remainingQuota.requestsRemaining / parameters.remainingQuota.requestsQuota;
    let quotaPercentRemainingPerDay = quotaPercentRemaining / parameters.remainingQuota.daysRemaining;
    providers[provideIndex].priority = quotaPercentRemainingPerDay;
    console.log(parameters.remainingQuota.requestsRemaining, "remains which is",
        quotaPercentRemaining, "% for ",
        parameters.remainingQuota.daysRemaining, "days which is ",
        quotaPercentRemainingPerDay, " per day");
}